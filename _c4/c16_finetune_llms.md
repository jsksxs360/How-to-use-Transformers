---
title: 第十六章：使用大语言模型
author: SHENG XU
date: 2024-07-25
category: NLP
layout: post
mathjax: yes
--- 

在上一章中我们讨论了预训练阶段的技术细节，本章将关注大语言模型构建过程的第二个阶段——微调（包括指令微调与人类对齐），以及最终的实际使用方法。

## 16.1 指令微调

如 14.2.2 节指令微调与人类对齐中所述，指令微调首先收集或构建自然语言形式的指令实例，然后通过有监督的方式对大语言模型的参数进行微调，因此又被称为有监督微调（Supervised Fine-tuning, SFT）或多任务提示训练（Multitask Prompted Training）。指令微调后的大语言模型能够具有较强的指令遵循能力，从而可以通过零样本学习的方式解决多种下游任务。

本节将首先介绍指令数据的构建方法和相应的训练策略，然后介绍低资源场景下的参数高效微调方法。

### 16.1.1 指令数据的构建

指令格式化的数据实例一般包括任务描述（也称为指令）、任务输入-任务输出以及可选的示例。本教程已经在14.2.4 节常用微调数据集中介绍了一些代表性的指令数据集。下面将介绍三种构建格式化指令数据的方法。

**基于现有的 NLP 任务数据集构建**

已有的 NLP 任务数据集是非常重要的数据资源，可以用于构造指令数据集。这些集合中的数据一般包括输入和输出两个部分，例如在中英翻译任务中，输入是“大语言模型...”、输出则是“Large language models...”。因此，生成指令化数据的关键步骤就是为“输入-输出”添加任务描述信息（指令），用于指导模型理解任务目标。例如对于前面的翻译任务，就可以添加指令“请把这个中文句子翻译成英文”。

> **相关**
>
> 研究表明在现有 NLP 数据集的“输入-输出”数据中添加合适的任务描述是提升大模型指令跟随能力的关键。如果去除任务描述，仅使用“输入-输出”数据对模型进行微调，性能会出现显著下降。
{: .block-warning}

<img src="/assets/img/finetune-llms/format_nlp_datasets.jpg" alt="instruction_formatting_nlp_datasets" style="display: block; margin: auto; width: 500px">

<center>图 16-1 现有 NLP 数据集的指令格式化示意图</center>

为此，研究者开发了众包平台 [PromptSource](https://github.com/bigscience-workshop/promptsource)，能够高效地支持标注人员为不同数据集创建、共享及验证任务描述，如图 16-1 所示。此外，还可以设计特定的任务描述来翻转现有实例的“输入-输出”对，例如，对于“问题-答案”对，既可以基于问题预测答案，也可以基于答案生成问题，比如使用指令“请基于以下答案生成一个问题：”。

> **延伸**
>
> 如 14.2.4 节常用微调数据集中所述，谷歌按照一定的比例混合了 FLAN、P3、SuperNatural Instructions 等集合以及思维链数据，推出了包含约 20M 条实例的指令微调数据集 FLAN v2，该数据集目前是微调大语言模型的首选指令集合。
{: .block-tip}

**基于日常对话数据构建**

指令格式化已有的 NLP 数据集虽然能够获得大量实例，但是数据多样性比较小而且也不能很好匹配人类的真实需求。因此另一种方式是使用用户在日常对话中的实际需求作为任务描述，例如 InstructGPT 将用户提交给 OpenAI API 的查询作为任务描述。

最近研究者开源了一些由人工精心标注的日常对话指令集，例如 Dolly 和 OpenAssistant。此外，研究者还尝试通过自行构建的开放平台收集大量的用户对话请求作为输入数据，并使用 ChatGPT 或 GPT-4 生成回复作为输出，ShareGPT 数据集便是一个代表。

**基于合成数据构建**

为了减轻人工收集与标注数据的负担，研究者进一步提出半自动化的数据合成方法，将已有的高质量指令数据作为上下文学习示例输入大语言模型， 然后生成大量多样化的任务描述和输入-输出数据，如图 16-2 所示。代表性方法 [Self-Instruct](https://aclanthology.org/2023.acl-long.754/) 仅需要使用 100 多个人工撰写的实例作为初始任务池，然后随机选择数据作为示例，就可以通过大语言模型生成新的指令微调数据。

<img src="/assets/img/finetune-llms/synthesize_data.jpg" alt="synthesize_data" style="display: block; margin: auto; width: 600px">

<center>图 16-2 合成指令数据示意图</center>

考虑到 Self-Instruct 生成的实例可能过于简单或缺乏多样性，研究者还提出了改进的指令数据合成方法 [Evol-Instruct](https://arxiv.org/abs/2304.12244)，该方法通过基于深度和广度的演化来提高实例的复杂性和多样性。

> **延伸**
>
> 研究表明一定数量的高质量指令就可以激活大语言模型的对话能力。例如 [Alpaca](https://github.com/tatsu-lab/stanford_alpaca) 使用了 52K 条 合成数据来指令微调 LLaMA (7B)，在 179 条日常对话数据的评测中到达了接近 text-davinci-003 的效果。[LIMA](https://proceedings.neurips.cc/paper_files/paper/2023/hash/ac662d74829e4407ce1d126477f4a03a-Abstract-Conference.html) 仅使用了一千条人工标注的高质量指令数据来微调 LLaMA (65B)，就在 300 条日常对话测试中取得了较好的模型表现。
>
> 因此，**指令的质量比数量更为重要**。指令微调中应优先使用人工标注的多样性指令数据。在实践中可以使用 ChatGPT、GPT-4 等闭源大语言模型来合成、重写、筛选现有指令。例如 Alpagasus 从原始的 52K 条 Alpaca 数据中筛选出 GPT-4 评分较高的 9 千条进行指令微调训练，便可达到与原始 52K 条数据接近的效果。
{: .block-tip}

### 16.1.2 参数高效微调方法 LoRA

通过指令微调，大语言模型能够更好地遵循和执行人类指令。但是，由于大语言模型的参数量巨大，进行全参数微调需要较多的算力资源。因此研究者提出了参数高效微调（Parameter-efficient Fine-tuning），也称为轻量化微调（Lightweight Fine-tuning），在减少训练参数量的同时使得模型性能能够与全量微调相媲美。

其中，低秩适配（Low-Rank Adaptation, LoRA）是大语言模型最常用的参数高效微调方法，其通过在模型的参数矩阵上添加低秩分解矩阵来近似每层的参数更新，如图 16-3 所示。

<img src="/assets/img/finetune-llms/lora.jpg" alt="lora" style="display: block; margin: auto; width: 700px">

<center>图 16-3 LoRA 微调示意图</center>

给定一个参数矩阵 $\boldsymbol{W}$，其更新过程可以一般性地表达为如式 (16.1) 所示：

$$
\boldsymbol{W} = \boldsymbol{W}_0 + \Delta\boldsymbol{W} \tag{16.1}
$$

其中 $\boldsymbol{W}_0$ 是原始参数矩阵，$\Delta\boldsymbol{W}$ 是更新的梯度矩阵。LoRA 的基本思想是冻结原始矩阵 $\boldsymbol{W}_0 \in \mathbb{R}^{H\times H}$，通过低秩分解矩阵 $\boldsymbol{A}\in\mathbb{R}^{H\times R}$ 和 $\boldsymbol{B}\in\mathbb{R}^{H \times R}$ 来近似参数更新矩阵 $\Delta\boldsymbol{W}=\boldsymbol{A}\cdot\boldsymbol{B}^{\top}$，其中 $R \ll H$ 是减小后的秩。在微调期间，原始的矩阵参数 $\Delta\boldsymbol{W}$ 不会被更新，低秩分解矩阵 $\boldsymbol{A}$ 和 $\boldsymbol{B}$ 则是可训练参数用于适配下游任务。

在前向传播过程中，原始计算中间状态 $\boldsymbol{h} = \boldsymbol{W}_0\cdot \boldsymbol{x}$ 的公式修改为：

$$
\boldsymbol{h} = \boldsymbol{W}_0\cdot \boldsymbol{x} +\boldsymbol{A}\cdot\boldsymbol{B}^{\top}\cdot\boldsymbol{x} \tag{16.2}
$$

在训练完成后，进一步将原始参数矩阵 $\boldsymbol{W}_0$ 和训练得到的权重 $\boldsymbol{A}$ 和 $\boldsymbol{B}$ 进行合并：$\boldsymbol{W} = \boldsymbol{W}_0 + \boldsymbol{A}\cdot\boldsymbol{B}^{\top}$，得到更新后的参数矩阵。因此，LoRA 微调得到的模型在解码过程中不会增加额外的开销。

> **延伸**
>
> LoRA 微调方法还存在一些变种。例如 [AdaLoRA](https://arxiv.org/abs/2303.10512) 引入了动态低秩适应技术，在训练过程中动态调整每个参数矩阵需要训练的秩同时控制训练的参数总量。[QLoRA](https://proceedings.neurips.cc/paper_files/paper/2023/hash/1feb87871436031bdc0f2beaa62a049b-Abstract-Conference.html) 将原始的参数矩阵量化为 4 比特，而低秩参数部分仍使用 16 比特进行训练，在保持微调效果的同时进一步节省了显存开销。
{: .block-tip}

## 16.2 人类对齐

经过预训练和指令微调后，大语言模型具备了解决各种任务的通用能力和指令遵循能力，但是受到数据质量、数据来源以及具体创作者等多方面的影响，也可能生成有偏见的、冒犯的以及事实错误的文本内容。因此，如何确保大语言模型的行为与人类价值观、人类真实意图和社会伦理相一致成为了一个重要问题，称为人类对齐（Human Alignment）。

### 16.2.1 基于人类反馈的强化学习

由于有用性（Helpfulness）、诚实性（Honesty）和无害性（Harmlessness）等对齐标准难以通过形式化的优化目标进行建模，因此研究者提出了基于人类反馈的强化学习（Reinforcement Learning from Human Feedback, RLHF），引入人类反馈对大语言模型的行为进行指导。

RLHF 首先使用收集到的人类偏好数据训练奖励模型，最后基于奖励模型使用强化学习算法（例如 Proximal Policy Optimization, [PPO](https://arxiv.org/abs/1707.06347)）微调大语言模型。RLHF 的完整工作流程可以分为监督微调、奖励模型训练、强化学习微调三个阶段，如图 16-4 所示。

<img src="/assets/img/finetune-llms/rlhf.jpg" alt="rlhf" style="display: block; margin: auto; width: 900px">

<center>图 16-4 RLHF 的工作流程</center>

**阶段一、监督微调**

为了让待对齐语言模型具有较好的指令遵循能力，首先需要收集高质量的指令数据进行监督微调，即 16.1 节中介绍的指令微调。

**阶段二、奖励模型训练**

第二步是使用人类反馈数据训练奖励模型。具体来说，首先使用模型对任务指令生成一定数量的候选输出；然后邀请标注员对输出文本进行偏好标注，可以采用多种形式，最常用的是对候选文本进行排序标注（可以有效减少多个标注员之间的不一致情况）；最后使用人工标注的偏好数据训练奖励模型，使其能够建模人类偏好。例如在 InstructGPT 中，标注员将模型生成的输出按照最佳到最差的顺序进行排序，然后训练奖励模型来预测这个排序。

> **延伸**
>
> 在现有工作中，主要有两种人类反馈数据的形式：基于评分的人类反馈和基于排序的人类反馈。
>
> 最直接的标注方式是根据预设的标准邀请标注人员对模型的输出进行打分，例如遵守某条规则记 1 分而违反某条规则扣 1 分。除了人工标注外，还可以使用经过对齐的大语言模型对于特定对齐标准进行标注。
>
> 排序是另一种典型的人类偏好标注形式。最简单的方式是要求标注人员根据自身偏好对大语言模型的输出进行全排序，但是这种方 式需要花费较多的人力成本。目前更常见的做法是引入竞技比赛中衡量参与者相对实力的 Elo 评分系统，通过对模型输出进行两两比较，进而计算每个输出的综合得分并获得最终的输出排序。
{: .block-tip}

奖励模型的训练方式主要包括如下三种形式：

- 打分式：对给定的输入问题，为相应的输出赋予反馈分数，通常是离散的数值，用于表示输出与人类偏好的契合程度。一般采用均方误差（Mean Square Error, MSE）作为打分式训练方法的目标函数。
- 对比式：仅需对两条输出进行排序，排序在前的输出被视为正例（更符合人类偏好），另一条输出则被视为负例。这种标注方式不仅降低了标注难度，还提高了不同标注者之间的一致性。通常采用对比学习方法训练奖励模型。
- 排序式：可以被视为对比式训练方法的增强形式。对于一个给定的输入，对多个模型回复进行排序。通过标注的顺序，可以获得回复之间的相对优劣关系，即哪些回复更符合人类价值观。通常采用与对比式方法类似的学习策略训练奖励模型。

**步骤三：强化学习训练**

待对齐语言模型担任策略实施者（称为策略模型），它接收提示作为输入并返回输出文本，其动作空间是词汇表中的所有词元，状态指的是当前已生成的词元序列。奖励模型则根据当前语言模型的状态提供相应的奖励分数，用于指导策略模型的优化。为了避免语言模型明显偏离初始模型，通常会在优化目标中加入一个惩罚项，如当前语言模型与初始语言模型生成结果之间的 KL 散度。这个对齐过程可以进行多次迭代，从而更好地对齐大语言模型。

> **延伸**
>
> 目前 RLHF 中最常使用的是近端策略优化（Proximal Policy Optimization, PPO）算法，在策略梯度（Policy Gradient）算法的基础上，使用优势估计来更加准确的评估决策轨迹能获得的奖励，并且使用重要性采样来进行离线策略训练。此外，为了保证重要性采样的稳定性，PPO 算法通过在目标函数中加入梯度裁剪以及相关的惩罚项来减小采样误差。
>
> 为了能够实现上述优化过程，PPO 算法在策略模型和奖励模型的基础上，还引入了参考模型和评价模型。
{: .block-tip}

### 16.2.2 非强化学习的对齐方法

尽管 RLHF 是一种有效的对齐技术，但是它也存在一 些局限性：首先，RLHF 训练过程中需要同时维护和更新多个模型，包括策略模型、奖励模型、参考模型以及评价模型，不仅会占用大量的内存，而且算法的执行过程也相对复杂；其次，RLHF 中常用的 PPO 算法在优化过程中稳定性不佳，对超参数的取值较为敏感，进一步增加了模型训练的难度和不确定性。

为此，研究人员提出了一系列直接基于监督微调的对齐方法，以避免复杂的强化学习算法所带来的种种问题。

非强化学习的对齐方法旨在利用高质量的对齐数据集，通过特定的监督学习算法对大语言模型进行微调。这类方法需要建立精心构造的高质量对齐数据集，利用其中蕴含的人类价值观信息来指导模型正确地响应人类指令或规避生成不安全内容。与指令微调方法不同，基于监督微调的对齐方法需要在优化过程中使得模型能够区分对齐的数据和未对齐的数据（或者对齐质量的高低），进而直接从这些数据中学习到人类期望的行为模式。

**对齐数据的收集**

为了构建有效的对齐数据集，一些方法尝试利用训练好的奖励模型对众多候选输出进行打分或者排序，筛选出最符合人类偏好的数据；其他方法则利用经过对齐的大语言模型（例如 ChatGPT）来构造训练数据。

**代表性监督对齐算法 DPO**

直接偏好优化（Direct Preference Optimization, DPO）是一种不需要强化学习的对齐算法，其主要思想是建立决策函数与奖励函数之间的关系，以规避奖励建模的过程。这样，大语言模型就能够通过与强化学习等价的形式学习到人类的价值观和偏好。

### 16.2.3 SFT 和 RLHF 的进一步讨论

如 16.1 节所述，指令微调是一种基于格式化的指令示例数据（即任务描述与期望输出相配对的数据）对大语言模型进行训练的过程，也被称为监督微调（Supervised Fine-Tuning, SFT），而 RLHF 算法的第一个步骤就是监督微调（SFT）。本节将深入探讨这两者之间的联系与差异。

**学习方式**

在学习方式方面，RLHF 首先学习一个奖励模型，然后利用该奖励模型通过强化学习算法（如 PPO）来改进大语言模型。而 SFT 则采用了 Teacher-Forcing 的方法，直接优化模型对实例输出的预测概率。从本质上说，SFT 这种词元级别的训练方式是一种“行为克隆”，它利用教师的行为数据（即每个步骤的目标词元）作为监督标签，来直接训练大语言模型模仿教师的行为。

**SFT 的优缺点**

SFT 在实现上简单、灵活、可拓展性较强，还可以用于构建很多特定功能，例如帮助大语言模型建立聊天机器人的身份。但是其作用在于“解锁”大语言模型的能力，而非向大语言模型“注入”新能力。因此，试图通过 SFT 激发大语言模型的非内生能力时，可能会出现一些负面问题。当待学习的标注指令数据超出了大语言模型的知识或能力范围，例如训练大语言模型回答关于模型未知事实的问题时，可能会加重模型的幻觉（Hallucination）行为。此外，作为一种基于行为克隆的学习方法，SFT 旨在模仿构建标注数据的教师的行为，而无法在这一过程中进行有效的行为探索。因此，高质量的指令数据（而非数量）是影响大语言模型训练的主要因素。

**RLHF 的优缺点**

在数据标注阶段，RLHF 相比 SFT 具有两项潜在优势：首先，RLHF 算法的标注员主要为训练过程提供偏好标注数据，而不是直接生成示例数据，因此它可以减少标注员之间的不一致；其次，与编写示例数据相比，偏好标注更为简单易行，标注员甚至可以评估超出自己创作水平模型的输出质量，使得模型能够探索标注员能力之外的状态空间，而不用受限于给定的教师示例。

在模型学习阶段，RLHF 通过对比模型的输出数据（区分“好”输出与“坏” 输出）来指导大语言模型学习正确的生成策略，它不再强迫大语言模型模仿教师的示例数据，因此可以缓解 SFT 所导致的幻觉问题。然而，RLHF 也继承了经典强化学习算法的缺点，如样本学习效率低和训练过程不稳定等问题。 因此，RLHF 需要依赖经过 SFT 的模型作为策略模型的初始模型，从而快速达到较好的表现。此外，RLHF 的过程通常会持续多轮，其中涉及了很多重要细节的设定（例如提示选择、奖励模型训练、PPO 的超参数设置以及训练过程中对超参数的调整），都会影响整个模型的性能，对于复现提出了较大挑战。

总的来说，SFT 特别适合预训练后增强模型的性能，具有实现简单、快速高效等优点；而 RLHF 可在此基础上规避可能的有害行为并进一步提高模型性能，但是实现较为困难，不易进行高效优化。

## 16.3 使用大语言模型

### 16.3.1 解码加速算法

大语言模型是通过文本生成的方式进行工作的。在自回归架构中，模型针对输入内容 （即提示文本）逐个单词生成输出内容的文本，这个过程被称为解码。因此如 10.4 节中介绍的那样，需要束搜索、Top-$k$ 采样、Top-$p$ 采样等解码策略来生成输出内容。但是由于自回归算法的序列化生成的特点，解码算法存在效率较低的问题。目前一般通过系统级优化方法以及解码策略优化方法来缓解这一问题。

**系统级优化**

一些研究工作提出了系统级优化方法来实现减少访存量的目的。

- [FlashAttention](https://arxiv.org/abs/2307.08691)：一种针对原始注意力模块的优化方案，可以大幅减少注意力计算中的访存量，其核心思路是尽可能减少对于中间结果的保存，进而直接得到最终结果。FlashAttention 通过矩阵分块和算子融合等方法，将中间结果一直保留在缓存中，直到获得最终结果后再写回显存中，从而减少了显存读写量。

  > **延伸**
  >
  > FlashAttention 有效地减少了访存量，同时也降低了峰值显存的占用量。使用了 FlashAttention 的 LLaMA-2 (7B) 在序列长度为 2048、批次大小为 8 的情况下，注意力操作的时间仅需传统注意力的十分之一。
  {: .block-tip}

- [PagedAttention](https://dl.acm.org/doi/abs/10.1145/3600006.3613165)：针对键值缓存拼接和注意力计算的优化方案，能够有效降低这两个运算部分的访存量。在键值缓存拼接方面，PagedAttention 引入了操作系统中显存分页管理的方法，预先将显存划分成若干块给之后的键值缓存“预留空间”，从而显著减少了拼接时反复分配显存的操作。在注意力计算方面，PagedAttention 使用算子融合的方法将查询向量与多个分页的键值缓存并行地进行计算，从而减少其访存量。

- 批次管理优化：一个代表性的方法连续批处理（Continuous Batching）技术，通过启发式算法选择部分请求进行全量解码操作，或者选择一些请求进行单步增量解码操作，从而在一步操作中能够容纳更多的请求（相当于提高批次大小）。此外，DeepSpeed-MII 提出了动态分割技术，将全量解码部分进一步拆分为多个子操作，可以在一次计算中选择一些请求同时进行全量解码和增量解码操作，进而获得更大的批次和更高的解码吞吐量。

  通过批次管理优化技术细粒度地分割不同请求的处理阶段，使得不同请求的处理过程可以同时进行，从而实现更为高效的线上服务。

**解码策略优化**

还有许多研究工作提出了针对自回归解码策略的改进方法以提高解码效率。

- [推测解码](https://proceedings.mlr.press/v202/leviathan23a.html)：首先使用相对较小但解码更为高效的模型（例如 $n$ 元统计模型或者小型预训练模型）自回归地生成若干个词元，然后再由大模型对这个片段进行一次验证（大模型一次验证与一次解码的时间消耗相当）来判断是否每个词元都是当前步骤概率最高的输出，随后大小模型持续迭代此过程直到解码结束。

  推测解码不会降低大模型解码的质量， 实验测试表明能够带来约两倍左右的解码加速，是目前使用较多的解码策略优化方案。

- [级联解码](https://arxiv.org/abs/2305.05176)：使用不同规模的模型来处理难易度不同的请求。引入一系列效率从高到低的模型，然后将请求依次给这些模型进行生成，再由一个专门训练的二分类模型来判断生成结果是否符合要求，如果结果可靠就不需要再给之后的模型进行生成。

- 非自回归解码：机器翻译领域的研究人员提出了非自回归解码机制，可以基于输入并行地一次性生成所有的词元。但是这种方法的生成质量往往与自回归方法有一定差距，因此有研究工作提出了半自回归解码，每一次生成一组词元（例如 3 至 10 个），再以这些词元作为输入继续生成下一组。

  然而，现有的大模型都是预测下一个词进行预训练的， 无法直接进行非（半）自回归生成。为此，[Medusa](https://arxiv.org/abs/2401.10774) 在 Vicuna 模型的基础上，额外训练了两个预测头来分别预测第二个词和第三个词，因此可以一次生成三个词元。

  > **注意**
  >
  > 尽管非（半）自回归策略在效率上有所提升，但仍然不能达到自回归解码的效果，因此其很少单独使用。通常用于推测解码中生成候选片段。
  {: .block-danger}

### 16.3.2 低资源部署策略

由于大模型参数量巨大，在解码阶段需要占用大量的显存资源，因而在实际应用中的部署代价非常高。为此，研究者提出了模型量化（Model Quantization）技术来减少大模型的显存占用。

[量化](https://arxiv.org/abs/2103.13630)是指从浮点数到整数的映射过程，比较常用的是 8 比特整数量化，即 INT8 量化。神经网络模型通常有两种类型的数据需要进行量化，分别为权重量化（也称模型参数量化）和激活值量化。量化的过程可以表示为一个函数，该函数将连续的输入映射到离散的输出集合。一般来说，这个过程涉及到四舍五入或截断等近似操作。作为上述变换的逆过程，反量化（Dequantization）对应地从量化值中恢复原始值。

大语言模型相关的量化方法大致上可以分为两大类：量化感知训练（Quantization-Aware Training, QAT）和训练后量化（Post-Training Quantization, PTQ）。其中量化感知训练方法需要更新权重进而完成模型量化，而训练后量化方法则无需更新模型权重。一般来说，训练后量化方法需要更少的算力开销，实践中应用更为广泛。

针对大语言模型的量化研究受到了学术界的广泛关注，涌现了一批经验性的研究工作。下面针对目前的研究结论进行简要汇总：

- **INT8 权重量化通常对于大语言模型性能的影响较小，更低精度权重量化的效果取决于具体的量化方法**。在大多数情况下，INT8 权重量化可以有效地减小显存占用而不显著影响模型性能。对于 INT4（或 INT3）权重量化，现有的方法通常使用不同策略（例如激活感知缩放）来减少性能下降。

  低比特权重量化对于大语言模型的影响通常较小。因此，在相同显存开销的情况下，建议优先使用参数规模较大的语言模型，而不是表示精度较高的语言模型。例如量化精度为 4 比特的 60GB 语言模型在性能上往往会优于量化精度 8 比特的 30GB 语言模型。

- **轻量化微调方法可以用于补偿量化大语言模型的性能损失**。大语言模型在超低比特权重量化时（如 2 比特量化），可能会出现预测精度的大幅下 降，此时可以通过轻量化微调（如 LoRA ）的方式来进行性能补偿。具体来说，对不微调的模型权重进行低比特量化，而对于微调的适配器参数则使用 16 比特浮点数表示并使用 LoRA 算法进行微调。在推理时，量化部分的模型权重会先反量化为 16 比特浮点数，再与适配器权重相加进行融合使用。此外，QLoRA 更为针对性地设计了面向量化模型的性能补偿方法，在轻量化微调的同时还考虑了显存优化。实验表明，QLoRA 在基于 4 比特量化模型的微调后，能够获得与 16 比特模型全参数微调以及 LoRA 微调相似的效果。

### 16.3.3 模型蒸馏和模型剪枝

除了模型量化之外，模型蒸馏和模型剪枝也是常用的模型压缩方法，它们通过直接精简模型结构以减少参数数量。

**模型蒸馏**

模型蒸馏（Model Distillation）的目标是将复杂模型（称为教师模型）包含的知识迁移到简单模型（称为学生模型）中。以分类问题 为例，模型蒸馏的核心思想是引入额外的损失函数（称为蒸馏损失函数），训练学生模型的输出尽可能接近教师模型的输出。在实际应用中，蒸馏损失函数通常与分类损失函数（交叉熵损失函数）联合用于训练学生模型。

传统的模型蒸馏方法包括两种：基于反馈的知识蒸馏方法和基于特征的知识蒸馏方法。如图 16-5 所示。

<img src="/assets/img/finetune-llms/model_distillation.jpg" alt="model_distillation" style="display: block; margin: auto; width: 800px">

<center>图 16-5 基于反馈的知识蒸馏和基于特征的知识蒸馏</center>

基于反馈的知识蒸馏主要关注教师模型最后一层输出的 logits，这些 logits 经过 softmax 变换后作为学生模型的“软标签”进行学习，优化目标是让学生模型输出的 logits 去近似教师模型输出的 logits，从而学习到教师模型的特有知识；而基于特征的知识蒸馏则关注教师模型的中间层输出的激活值，并使用这些激活值作为监督信息训练学生模型。相较于最终的预测分布，中间层特征提供了更为丰富的模型信息，有助于在模型蒸馏过程中实现更为有效的知识迁移。然而，这种方法也存在一些技术难点，如消除架构不一致的影响、目标层自动化选择等。

面向大语言模型的知识蒸馏旨在将大语言模型（教师模型）包含的知识迁移到小模型（学生模型）中。根据大语言模型权重是否可以获得，可以分别使用白盒模型蒸馏方法和黑盒模型蒸馏方法。其中，白盒模型蒸馏方法可以获取模型的权重来指导学生模型，典型的方法为 [MINILLM](https://arxiv.org/abs/2306.08543)；而黑盒模型蒸馏方法无法获得模型权重，只能使用大语言模型的输出信息来训练小模型，目前主要关注于蒸馏大模型的关键 能力，如上下文学习能力、思维链推理能力以及指令遵循能力。

> **相关**
>
> 以[思维链推理能力的蒸馏](https://aclanthology.org/2023.findings-acl.507/)为例，可以利用大语言模型生成输入样本的思维链推理过程，作为标签以外的额外补充信息来帮助引导小模型学习。这种方法通过引入大模型对于问题的求解思路来提供额外的监督信息，从而让学生模型同时学习预测标签以及大模型生成的推理过程解释。
{: .block-warning}

**模型剪枝**

模型剪枝（Model Pruning）的目标是在尽可能不损失模型性能的情况下，努力消减模型的参数数量。

传统模型剪枝方法一般可以被分为结构化剪枝和非结构化剪枝。结构化剪枝（Structured Pruning）旨在去除对于性能影响较小的模型组件，可以删除神经元、通道甚至中间层。其核心思想是在尽量保持模型预测精度的条件下，去除那些对于结果影响不大的结构单元，如注意力机制中的注意力头、前馈层权重中的特定维度等。而非结构化剪枝（Unstructured Pruning） 则主要关注去除模型权重矩阵中不重要的数值（不修改模型结构）。一般来说，非结构化剪枝会创建一个包含 0/1 的掩码矩阵，并将其与原始的权重相乘，其中 0 所在位置的权重则不会在模型的计算中产生作用。当剪枝完成后，那些被剪枝掉的位置只会存储数值 0，从而节省存储空间。

>**延伸**
>
>在实际应用中，非结构化剪枝一般可以实现更高的剪枝比率，但是不会显著加速模型的计算过程，因为被掩码的部分可能仍然需要参与计算。而结构化剪枝通过去除结构单元，可以显著减少所需的矩阵乘法次数，实现模型的压缩和加速。
{: .block-tip}

与传统的模型剪枝类似，大语言模型的剪枝方法分为结构化和非结构化剪枝两类。其中，非结构化剪枝一般容易获得更高的压缩率，典型工作包括 [SparseGPT](https://dl.acm.org/doi/abs/10.5555/3618408.3618822)，其可以实现 60% 模型参数的剪枝并较好保持困惑度。大模型结构化剪枝的研究也取得了较好的模型压缩效果，例如 [LLM-prune](https://proceedings.neurips.cc/paper_files/paper/2023/hash/44956951349095f74492a5471128a7e0-Abstract-Conference.html) 在 LLaMA (7B) 上剪枝了 20% 的参数并保持 93.6% 的预测精度、[Sheared LLaMA](https://arxiv.org/abs/2310.06694) 则将 LLaMA-2 (7B) 剪枝到 2.7B 参数规模并保持 87.8% 的预测精度。

### 16.3.4 提示学习

使用大语言模型解决实际任务常用的方法是设计合适的提示（Prompting），通过自然语言接口与大模型进行交互。目前，提示的设计主要依靠人工设计和自动优化两种策略来实现。为了更好地解决未见过的任务，一种典型的提示方法是上下文学习（In-context Learning, ICL），它将任务描述与示例以自然语言文本形式加入到提示中。此外，思维链提示（Chain-of-Thought, CoT）作为一种增强技术，将一系列中间推理步骤加入 到提示中，以增强复杂推理任务的解决效果。

关于提示学习的详细介绍请见附录A。

### 16.3.5 大模型应用

本节将围绕具有代表性的自然语言处理和信息检索领域介绍大模型的应用。

**自然语言处理**

下面简要介绍一下大语言模型在三大经典任务上的应用，包括序列标注、关系抽取以及文本生成，这些任务构成了许多自然语言处理系统和应用的基础，如图 16-6 所示。

<img src="/assets/img/finetune-llms/apply_llms_to_nlp.jpg" alt="apply_llms_to_nlp" style="display: block; margin: auto; width: 800px">

<center>图 16-6 大语言模型应用于自然语言处理任务</center>

对于序列标注任务，大语言模型只需通过上下文学习或构建特殊提示就能解决，而无须使用 B-I-O 标记。例如，仅需要给出提示（如“请识别出句子中包含的实体”）或任务示例（如“输入文本‘中华人民共和国今天成立了’，请抽取出其所包含的命名实体：‘中华人民共和国’”）即可自动抽取出实体。

对于关系抽取任务，大语言模型同样能够借助特定提示方法（如上下文学习等）来完成。但是，当关系标签规模较为庞大时，这些知识信息难以完全通过上下文学习的方式注入到大语言模型中，可能会导致效果较差。此时可以结合大语言模型和小模型，例如先利用小模型进行候选关系的初筛，再利用大模型进一步从初筛后的候选关系中推理出最合适关系；也可以采用大语言模型对数据进行初步标注，从而丰富可用于训练的小模型的标注数据。

文本生成任务，只需通过适当的提示方法，大语言模型就能展现出接近人类的表现。然而，大语言模型难以有效处理低资源语言或领域下的文本生成任务，例如马拉地语到英语的翻译。

**信息检索**

大语言模型拥有强大的语言理解、推理与生成能力，能够助力构建更为智能的信息检索系统；而信息检索技术能够高效地从外界获取所需要的相关信息，可以为大语言模型提供更为精确、可靠的上下文信息。如图 16-7 所示。

<img src="/assets/img/finetune-llms/apply_llms_to_search.jpg" alt="apply_llms_to_search" style="display: block; margin: auto; width: 800px">

<center>图 16-8 大语言模型应用于信息检索</center>

在大语言模型提升信息检索任务方面，主要包括利用大语言模型进行信息检索和大语言模型增强的信息检索模型。

- **利用大语言模型进行信息检索**：现代信息检索系统通常采用“检索-重排序”的流水线框架。利用大语言模型改进信息检索系统的工作可以分为两类。第一类在检索数据上微调大语言模型以构建检索器或重排序器，利用大语言模型的语义理解能力提高检索效果；第二类通过设计特殊的指令（例如“请判断下述查询和文档的相关程度”），直接引导大语言模型生成两者的相关程度（如相关度分类或者打分），用于对候选文档集合进行排序。出于效率考虑，大多数工作将大语言模型应用于重排序阶段。
- **大语言模型增强的信息检索模型**：大语言模型出色的语义理解与生成能力可以为信息检索模型补充相关性信息。一类方法通过构造特殊的提示，使得大语言模型能够充当标注者的角色，以较低成本完成大规模训练数据的标注工作，为传统检索模型补充高质量标注数据；第二类方法同样通过设计特殊的提示，利用大语言模型对输入查询进行改写，辅助信息检索模型精准理解用户的需求。此外，还可以利用大语言模型对查询进行详细解释和扩充。

在检索增强的大语言模型方面，考虑到大语言模型受限于训练数据的时效性和局限性，研究者提出了检索增强生成（Retrieval-Augmented Generation, RAG）技术。该技术旨在通过信息检索系统从外部知识库中获取相关信息，为大语言模型提供时效性强、领域相关的外部知识。然而，检索返回的结果可能由于检索质量、呈现格式、输入长度等问题，导致大语言模型不能很好地利用这些信息。此时，可以通过输入优化、指令微调和预训练策略进行缓解。

- **输入优化策略**：在检索增强生成的场景中，大语言模型主要面临两个挑战。首先，当处理包含多个参考文档的长文本时，其信息利用能力往往会下降；其次，检索到的结果中可能包含与任务无关的文档，这可能会干扰模型对关键信息的识别和处理。为此，可以使用过滤、压缩、摘要等技术，在文档和词元两个层级优化模型输入。
- **指令微调策略**：构造面向检索文档利用的指令数据，通过对大语言模型进行微调，提升其对文档信息的处理和理解能力。首先，需要确保模型能够平等地关注输入中不同位置（如开头、中间、结尾）的内容，以缓解某些位置的信息容易被忽略的问题；其次，当存在不相关信息时，大语言模型应尽可能地避免被这些信息干扰。
- **预训练策略**：如果大语言模型最终主要用于信息检索任务，还可以在预训练阶段采用特殊的学习任务对其检索生成能力进行针对性的加强。一种常见的策略是将语料库中文档的标题或第一段文字作为查询，其余内容作为期望的生成结果。也有一些工作将每段话分为长度相等的两部分，其中前半部分作为查询，后半部分作为期望的生成结果。

## 16.4 小结

本节简要介绍了在预训练阶段完成之后，使用大语言模型的具体方式，包括指令微调以及人类对齐操作的技术细节。此外，还介绍了一些实际使用大模型中的技术要点，并且讨论了大语言模型在自然语言处理和信息检索领域的应用。

在后面的章中，本教程将带领大家实际上手微调几个具有代表性的大语言模型。

## 参考

[[1]](https://llmbook-zh.github.io/) 赵鑫等.2024.大语言模型